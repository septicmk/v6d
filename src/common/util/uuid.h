/** Copyright 2020-2021 Alibaba Group Holding Limited.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#ifndef SRC_COMMON_UTIL_UUID_H_
#define SRC_COMMON_UTIL_UUID_H_

#if defined(__x86_64__)
#include <immintrin.h>
#include <x86intrin.h>
#endif

#include <cstdlib>
#include <limits>
#include <string>

namespace vineyard {

/**
 * @brief ObjectID is an opaque type for vineyard's object id. The object ID is
 * generated by vineyard server, the underlying type of ObjectID is a 64-bit
 * unsigned integer.
 */
using ObjectID = uint64_t;

/**
 * @brief ExternalID is an opaque type for vineyard's object. The External ID is
 * specified outside of vineyard for compatibility, the underlying type of
 * ObjectID is base64 string.
 */
using ExternalID = std::string;

/**
 * @brief Signature is an opaque type for vineyard's object. The signature of
 * an object keep unchange during migration. The underlying type of Signature
 * is a 64-bit unsigned integer.
 */
using Signature = uint64_t;

/**
 * @brief InstanceID is an opaque type for vineyard's instance ID id. The
 * underlying type of ObjectID is a 64-bit unsigned integer.
 */
using InstanceID = uint64_t;

// blob id: 1 + memory address (in vineyardd)
// non-blob id: 0 + random (rdstc)

inline void* GetBlobAddr(ObjectID const id) {
  return (id & 0x8000000000000000UL)
             ? reinterpret_cast<void*>(id & 0x7FFFFFFFFFFFFFFFUL)
             : nullptr;
}

inline ObjectID GenerateBlobID(const void* ptr) {
  return 0x8000000000000000UL | reinterpret_cast<uint64_t>(ptr);
}

inline ObjectID GenerateBlobID(const uintptr_t ptr) {
  return 0x8000000000000000UL | static_cast<uint64_t>(ptr);
}

constexpr inline ObjectID EmptyBlobID() { return 0x8000000000000000UL; }

inline ObjectID GenerateObjectID() {
#if defined(__x86_64__)
  return 0x7FFFFFFFFFFFFFFFUL & static_cast<uint64_t>(__rdtsc());
#else
  return 0x7FFFFFFFFFFFFFFFUL &
         static_cast<uint64_t>(rand());  // NOLINT(runtime/threadsafe_fn)
#endif
}

inline ObjectID GenerateSignature() {
#if defined(__x86_64__)
  return 0x7FFFFFFFFFFFFFFFUL & static_cast<uint64_t>(__rdtsc());
#else
  return 0x7FFFFFFFFFFFFFFFUL &
         static_cast<uint64_t>(rand());  // NOLINT(runtime/threadsafe_fn)
#endif
}

inline bool IsBlob(ObjectID id) { return id & 0x8000000000000000UL; }

const std::string ObjectIDToString(const ObjectID id);

inline ObjectID ObjectIDFromString(const std::string& s) {
  return strtoull(s.c_str() + 1, nullptr, 16);
}

inline ObjectID ObjectIDFromString(const char* s) {
  return strtoull(s + 1, nullptr, 16);
}

[[deprecated(
    "For backwards-compatiblity, will be removed in 1.0.")]] inline const std::
    string
    VYObjectIDToString(const ObjectID id) {
  return ObjectIDToString(id);
}

[[deprecated(
    "For backwards-compatiblity, will be removed in 1.0.")]] inline ObjectID
VYObjectIDFromString(const std::string& s) {
  return ObjectIDFromString(s);
}

[[deprecated(
    "For backwards-compatiblity, will be removed in 1.0.")]] inline ObjectID
VYObjectIDFromString(const char* s) {
  return ObjectIDFromString(s);
}

const std::string SignatureToString(const Signature id);

inline Signature SignatureFromString(const std::string& s) {
  return strtoull(s.c_str() + 1, nullptr, 16);
}

inline Signature SignatureFromString(const char* s) {
  return strtoull(s + 1, nullptr, 16);
}

inline ObjectID InvalidObjectID() {
  return std::numeric_limits<ObjectID>::max();
}

inline ObjectID InvalidSignature() {
  return std::numeric_limits<Signature>::max();
}

inline InstanceID UnspecifiedInstanceID() {
  return std::numeric_limits<InstanceID>::max();
}

}  // namespace vineyard

#endif  // SRC_COMMON_UTIL_UUID_H_
